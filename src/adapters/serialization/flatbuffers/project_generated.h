// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PROJECT_PLANT_COMPOSER_FBS_H_
#define FLATBUFFERS_GENERATED_PROJECT_PLANT_COMPOSER_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace plant_composer {
namespace fbs {

struct FileNode;
struct FileNodeBuilder;

struct FolderNode;
struct FolderNodeBuilder;

struct ProjectCategory;
struct ProjectCategoryBuilder;

struct Project;
struct ProjectBuilder;

enum ProjectNode : uint8_t {
  ProjectNode_NONE = 0,
  ProjectNode_FileNode = 1,
  ProjectNode_FolderNode = 2,
  ProjectNode_MIN = ProjectNode_NONE,
  ProjectNode_MAX = ProjectNode_FolderNode
};

inline const ProjectNode (&EnumValuesProjectNode())[3] {
  static const ProjectNode values[] = {
    ProjectNode_NONE,
    ProjectNode_FileNode,
    ProjectNode_FolderNode
  };
  return values;
}

inline const char * const *EnumNamesProjectNode() {
  static const char * const names[4] = {
    "NONE",
    "FileNode",
    "FolderNode",
    nullptr
  };
  return names;
}

inline const char *EnumNameProjectNode(ProjectNode e) {
  if (::flatbuffers::IsOutRange(e, ProjectNode_NONE, ProjectNode_FolderNode)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProjectNode()[index];
}

template<typename T> struct ProjectNodeTraits {
  static const ProjectNode enum_value = ProjectNode_NONE;
};

template<> struct ProjectNodeTraits<plant_composer::fbs::FileNode> {
  static const ProjectNode enum_value = ProjectNode_FileNode;
};

template<> struct ProjectNodeTraits<plant_composer::fbs::FolderNode> {
  static const ProjectNode enum_value = ProjectNode_FolderNode;
};

bool VerifyProjectNode(::flatbuffers::Verifier &verifier, const void *obj, ProjectNode type);
bool VerifyProjectNodeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct FileNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_FILE_PATH = 8
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *file_path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILE_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_FILE_PATH) &&
           verifier.VerifyString(file_path()) &&
           verifier.EndTable();
  }
};

struct FileNodeBuilder {
  typedef FileNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(FileNode::VT_ID, id);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FileNode::VT_NAME, name);
  }
  void add_file_path(::flatbuffers::Offset<::flatbuffers::String> file_path) {
    fbb_.AddOffset(FileNode::VT_FILE_PATH, file_path);
  }
  explicit FileNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileNode>(end);
    fbb_.Required(o, FileNode::VT_ID);
    fbb_.Required(o, FileNode::VT_NAME);
    fbb_.Required(o, FileNode::VT_FILE_PATH);
    return o;
  }
};

inline ::flatbuffers::Offset<FileNode> CreateFileNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> file_path = 0) {
  FileNodeBuilder builder_(_fbb);
  builder_.add_file_path(file_path);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FileNode> CreateFileNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *name = nullptr,
    const char *file_path = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto file_path__ = file_path ? _fbb.CreateString(file_path) : 0;
  return plant_composer::fbs::CreateFileNode(
      _fbb,
      id__,
      name__,
      file_path__);
}

struct FolderNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FolderNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_PARENT_ID = 6,
    VT_NAME = 8,
    VT_CHILDREN_TYPE = 10,
    VT_CHILDREN = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *parent_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PARENT_ID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *children_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHILDREN_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *children() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_CHILDREN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_PARENT_ID) &&
           verifier.VerifyString(parent_id()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_CHILDREN_TYPE) &&
           verifier.VerifyVector(children_type()) &&
           VerifyOffsetRequired(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           VerifyProjectNodeVector(verifier, children(), children_type()) &&
           verifier.EndTable();
  }
};

struct FolderNodeBuilder {
  typedef FolderNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(FolderNode::VT_ID, id);
  }
  void add_parent_id(::flatbuffers::Offset<::flatbuffers::String> parent_id) {
    fbb_.AddOffset(FolderNode::VT_PARENT_ID, parent_id);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(FolderNode::VT_NAME, name);
  }
  void add_children_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> children_type) {
    fbb_.AddOffset(FolderNode::VT_CHILDREN_TYPE, children_type);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> children) {
    fbb_.AddOffset(FolderNode::VT_CHILDREN, children);
  }
  explicit FolderNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FolderNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FolderNode>(end);
    fbb_.Required(o, FolderNode::VT_ID);
    fbb_.Required(o, FolderNode::VT_NAME);
    fbb_.Required(o, FolderNode::VT_CHILDREN_TYPE);
    fbb_.Required(o, FolderNode::VT_CHILDREN);
    return o;
  }
};

inline ::flatbuffers::Offset<FolderNode> CreateFolderNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> parent_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> children_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> children = 0) {
  FolderNodeBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_children_type(children_type);
  builder_.add_name(name);
  builder_.add_parent_id(parent_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FolderNode> CreateFolderNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *parent_id = nullptr,
    const char *name = nullptr,
    const std::vector<uint8_t> *children_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *children = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto parent_id__ = parent_id ? _fbb.CreateString(parent_id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto children_type__ = children_type ? _fbb.CreateVector<uint8_t>(*children_type) : 0;
  auto children__ = children ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*children) : 0;
  return plant_composer::fbs::CreateFolderNode(
      _fbb,
      id__,
      parent_id__,
      name__,
      children_type__,
      children__);
}

struct ProjectCategory FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProjectCategoryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_FOLDER_NAME = 8,
    VT_CHILDREN_TYPE = 10,
    VT_CHILDREN = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *folder_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FOLDER_NAME);
  }
  const ::flatbuffers::Vector<uint8_t> *children_type() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CHILDREN_TYPE);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *children() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *>(VT_CHILDREN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_FOLDER_NAME) &&
           verifier.VerifyString(folder_name()) &&
           VerifyOffsetRequired(verifier, VT_CHILDREN_TYPE) &&
           verifier.VerifyVector(children_type()) &&
           VerifyOffsetRequired(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           VerifyProjectNodeVector(verifier, children(), children_type()) &&
           verifier.EndTable();
  }
};

struct ProjectCategoryBuilder {
  typedef ProjectCategory Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ProjectCategory::VT_ID, id);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ProjectCategory::VT_NAME, name);
  }
  void add_folder_name(::flatbuffers::Offset<::flatbuffers::String> folder_name) {
    fbb_.AddOffset(ProjectCategory::VT_FOLDER_NAME, folder_name);
  }
  void add_children_type(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> children_type) {
    fbb_.AddOffset(ProjectCategory::VT_CHILDREN_TYPE, children_type);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> children) {
    fbb_.AddOffset(ProjectCategory::VT_CHILDREN, children);
  }
  explicit ProjectCategoryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ProjectCategory> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ProjectCategory>(end);
    fbb_.Required(o, ProjectCategory::VT_ID);
    fbb_.Required(o, ProjectCategory::VT_NAME);
    fbb_.Required(o, ProjectCategory::VT_FOLDER_NAME);
    fbb_.Required(o, ProjectCategory::VT_CHILDREN_TYPE);
    fbb_.Required(o, ProjectCategory::VT_CHILDREN);
    return o;
  }
};

inline ::flatbuffers::Offset<ProjectCategory> CreateProjectCategory(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> folder_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> children_type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<void>>> children = 0) {
  ProjectCategoryBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_children_type(children_type);
  builder_.add_folder_name(folder_name);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ProjectCategory> CreateProjectCategoryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *name = nullptr,
    const char *folder_name = nullptr,
    const std::vector<uint8_t> *children_type = nullptr,
    const std::vector<::flatbuffers::Offset<void>> *children = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto folder_name__ = folder_name ? _fbb.CreateString(folder_name) : 0;
  auto children_type__ = children_type ? _fbb.CreateVector<uint8_t>(*children_type) : 0;
  auto children__ = children ? _fbb.CreateVector<::flatbuffers::Offset<void>>(*children) : 0;
  return plant_composer::fbs::CreateProjectCategory(
      _fbb,
      id__,
      name__,
      folder_name__,
      children_type__,
      children__);
}

struct Project FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ProjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_DESCRIPTION = 8,
    VT_AUTHOR = 10,
    VT_VERSION = 12,
    VT_DIAGRAMS = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::String *author() const {
    return GetPointer<const ::flatbuffers::String *>(VT_AUTHOR);
  }
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  const plant_composer::fbs::ProjectCategory *diagrams() const {
    return GetPointer<const plant_composer::fbs::ProjectCategory *>(VT_DIAGRAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_AUTHOR) &&
           verifier.VerifyString(author()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffsetRequired(verifier, VT_DIAGRAMS) &&
           verifier.VerifyTable(diagrams()) &&
           verifier.EndTable();
  }
};

struct ProjectBuilder {
  typedef Project Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Project::VT_ID, id);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Project::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(Project::VT_DESCRIPTION, description);
  }
  void add_author(::flatbuffers::Offset<::flatbuffers::String> author) {
    fbb_.AddOffset(Project::VT_AUTHOR, author);
  }
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(Project::VT_VERSION, version);
  }
  void add_diagrams(::flatbuffers::Offset<plant_composer::fbs::ProjectCategory> diagrams) {
    fbb_.AddOffset(Project::VT_DIAGRAMS, diagrams);
  }
  explicit ProjectBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Project> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Project>(end);
    fbb_.Required(o, Project::VT_ID);
    fbb_.Required(o, Project::VT_DIAGRAMS);
    return o;
  }
};

inline ::flatbuffers::Offset<Project> CreateProject(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::String> author = 0,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    ::flatbuffers::Offset<plant_composer::fbs::ProjectCategory> diagrams = 0) {
  ProjectBuilder builder_(_fbb);
  builder_.add_diagrams(diagrams);
  builder_.add_version(version);
  builder_.add_author(author);
  builder_.add_description(description);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Project> CreateProjectDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *name = nullptr,
    const char *description = nullptr,
    const char *author = nullptr,
    const char *version = nullptr,
    ::flatbuffers::Offset<plant_composer::fbs::ProjectCategory> diagrams = 0) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto author__ = author ? _fbb.CreateString(author) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  return plant_composer::fbs::CreateProject(
      _fbb,
      id__,
      name__,
      description__,
      author__,
      version__,
      diagrams);
}

inline bool VerifyProjectNode(::flatbuffers::Verifier &verifier, const void *obj, ProjectNode type) {
  switch (type) {
    case ProjectNode_NONE: {
      return true;
    }
    case ProjectNode_FileNode: {
      auto ptr = reinterpret_cast<const plant_composer::fbs::FileNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ProjectNode_FolderNode: {
      auto ptr = reinterpret_cast<const plant_composer::fbs::FolderNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyProjectNodeVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyProjectNode(
        verifier,  values->Get(i), types->GetEnum<ProjectNode>(i))) {
      return false;
    }
  }
  return true;
}

inline const plant_composer::fbs::Project *GetProject(const void *buf) {
  return ::flatbuffers::GetRoot<plant_composer::fbs::Project>(buf);
}

inline const plant_composer::fbs::Project *GetSizePrefixedProject(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<plant_composer::fbs::Project>(buf);
}

inline const char *ProjectIdentifier() {
  return "PCPJ";
}

inline bool ProjectBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ProjectIdentifier());
}

inline bool SizePrefixedProjectBufferHasIdentifier(const void *buf) {
  return ::flatbuffers::BufferHasIdentifier(
      buf, ProjectIdentifier(), true);
}

inline bool VerifyProjectBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<plant_composer::fbs::Project>(ProjectIdentifier());
}

inline bool VerifySizePrefixedProjectBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<plant_composer::fbs::Project>(ProjectIdentifier());
}

inline const char *ProjectExtension() {
  return "pcp";
}

inline void FinishProjectBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<plant_composer::fbs::Project> root) {
  fbb.Finish(root, ProjectIdentifier());
}

inline void FinishSizePrefixedProjectBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<plant_composer::fbs::Project> root) {
  fbb.FinishSizePrefixed(root, ProjectIdentifier());
}

}  // namespace fbs
}  // namespace plant_composer

#endif  // FLATBUFFERS_GENERATED_PROJECT_PLANT_COMPOSER_FBS_H_
