// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DIAGRAM_PLANT_COMPOSER_FBS_H_
#define FLATBUFFERS_GENERATED_DIAGRAM_PLANT_COMPOSER_FBS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace plant_composer {
namespace fbs {

struct NodeTransform;

struct KeyValue;
struct KeyValueBuilder;

struct ComponentInstance;
struct ComponentInstanceBuilder;

struct Connection;
struct ConnectionBuilder;

struct DiagramTable;
struct DiagramTableBuilder;

enum ConnectionType : int8_t {
  ConnectionType_Port = 0,
  ConnectionType_Signal = 1,
  ConnectionType_MIN = ConnectionType_Port,
  ConnectionType_MAX = ConnectionType_Signal
};

inline const ConnectionType (&EnumValuesConnectionType())[2] {
  static const ConnectionType values[] = {
    ConnectionType_Port,
    ConnectionType_Signal
  };
  return values;
}

inline const char * const *EnumNamesConnectionType() {
  static const char * const names[3] = {
    "Port",
    "Signal",
    nullptr
  };
  return names;
}

inline const char *EnumNameConnectionType(ConnectionType e) {
  if (::flatbuffers::IsOutRange(e, ConnectionType_Port, ConnectionType_Signal)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConnectionType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) NodeTransform FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float rotation_;

 public:
  NodeTransform()
      : x_(0),
        y_(0),
        rotation_(0) {
  }
  NodeTransform(float _x, float _y, float _rotation)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        rotation_(::flatbuffers::EndianScalar(_rotation)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float rotation() const {
    return ::flatbuffers::EndianScalar(rotation_);
  }
};
FLATBUFFERS_STRUCT_END(NodeTransform, 12);

struct KeyValue FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyValueBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const ::flatbuffers::String *key() const {
    return GetPointer<const ::flatbuffers::String *>(VT_KEY);
  }
  const ::flatbuffers::String *value() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct KeyValueBuilder {
  typedef KeyValue Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_key(::flatbuffers::Offset<::flatbuffers::String> key) {
    fbb_.AddOffset(KeyValue::VT_KEY, key);
  }
  void add_value(::flatbuffers::Offset<::flatbuffers::String> value) {
    fbb_.AddOffset(KeyValue::VT_VALUE, value);
  }
  explicit KeyValueBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyValue> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyValue>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyValue> CreateKeyValue(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> key = 0,
    ::flatbuffers::Offset<::flatbuffers::String> value = 0) {
  KeyValueBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyValue> CreateKeyValueDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return plant_composer::fbs::CreateKeyValue(
      _fbb,
      key__,
      value__);
}

struct ComponentInstance FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ComponentInstanceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_COMPONENT_TYPE_ID = 8,
    VT_TRANSFORM = 10,
    VT_CONSTANTS = 12
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *component_type_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_COMPONENT_TYPE_ID);
  }
  const plant_composer::fbs::NodeTransform *transform() const {
    return GetStruct<const plant_composer::fbs::NodeTransform *>(VT_TRANSFORM);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::KeyValue>> *constants() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::KeyValue>> *>(VT_CONSTANTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_COMPONENT_TYPE_ID) &&
           verifier.VerifyString(component_type_id()) &&
           VerifyField<plant_composer::fbs::NodeTransform>(verifier, VT_TRANSFORM, 4) &&
           VerifyOffset(verifier, VT_CONSTANTS) &&
           verifier.VerifyVector(constants()) &&
           verifier.VerifyVectorOfTables(constants()) &&
           verifier.EndTable();
  }
};

struct ComponentInstanceBuilder {
  typedef ComponentInstance Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(ComponentInstance::VT_ID, id);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ComponentInstance::VT_NAME, name);
  }
  void add_component_type_id(::flatbuffers::Offset<::flatbuffers::String> component_type_id) {
    fbb_.AddOffset(ComponentInstance::VT_COMPONENT_TYPE_ID, component_type_id);
  }
  void add_transform(const plant_composer::fbs::NodeTransform *transform) {
    fbb_.AddStruct(ComponentInstance::VT_TRANSFORM, transform);
  }
  void add_constants(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::KeyValue>>> constants) {
    fbb_.AddOffset(ComponentInstance::VT_CONSTANTS, constants);
  }
  explicit ComponentInstanceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ComponentInstance> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ComponentInstance>(end);
    fbb_.Required(o, ComponentInstance::VT_ID);
    fbb_.Required(o, ComponentInstance::VT_COMPONENT_TYPE_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<ComponentInstance> CreateComponentInstance(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> component_type_id = 0,
    const plant_composer::fbs::NodeTransform *transform = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::KeyValue>>> constants = 0) {
  ComponentInstanceBuilder builder_(_fbb);
  builder_.add_constants(constants);
  builder_.add_transform(transform);
  builder_.add_component_type_id(component_type_id);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ComponentInstance> CreateComponentInstanceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *name = nullptr,
    const char *component_type_id = nullptr,
    const plant_composer::fbs::NodeTransform *transform = nullptr,
    const std::vector<::flatbuffers::Offset<plant_composer::fbs::KeyValue>> *constants = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto component_type_id__ = component_type_id ? _fbb.CreateString(component_type_id) : 0;
  auto constants__ = constants ? _fbb.CreateVector<::flatbuffers::Offset<plant_composer::fbs::KeyValue>>(*constants) : 0;
  return plant_composer::fbs::CreateComponentInstance(
      _fbb,
      id__,
      name__,
      component_type_id__,
      transform,
      constants__);
}

struct Connection FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConnectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TYPE = 6,
    VT_SOURCE_COMPONENT_ID = 8,
    VT_SOURCE_IO_ID = 10,
    VT_TARGET_COMPONENT_ID = 12,
    VT_TARGET_IO_ID = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  plant_composer::fbs::ConnectionType type() const {
    return static_cast<plant_composer::fbs::ConnectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *source_component_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_COMPONENT_ID);
  }
  const ::flatbuffers::String *source_io_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SOURCE_IO_ID);
  }
  const ::flatbuffers::String *target_component_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_COMPONENT_ID);
  }
  const ::flatbuffers::String *target_io_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TARGET_IO_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_SOURCE_COMPONENT_ID) &&
           verifier.VerifyString(source_component_id()) &&
           VerifyOffsetRequired(verifier, VT_SOURCE_IO_ID) &&
           verifier.VerifyString(source_io_id()) &&
           VerifyOffsetRequired(verifier, VT_TARGET_COMPONENT_ID) &&
           verifier.VerifyString(target_component_id()) &&
           VerifyOffsetRequired(verifier, VT_TARGET_IO_ID) &&
           verifier.VerifyString(target_io_id()) &&
           verifier.EndTable();
  }
};

struct ConnectionBuilder {
  typedef Connection Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(Connection::VT_ID, id);
  }
  void add_type(plant_composer::fbs::ConnectionType type) {
    fbb_.AddElement<int8_t>(Connection::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_source_component_id(::flatbuffers::Offset<::flatbuffers::String> source_component_id) {
    fbb_.AddOffset(Connection::VT_SOURCE_COMPONENT_ID, source_component_id);
  }
  void add_source_io_id(::flatbuffers::Offset<::flatbuffers::String> source_io_id) {
    fbb_.AddOffset(Connection::VT_SOURCE_IO_ID, source_io_id);
  }
  void add_target_component_id(::flatbuffers::Offset<::flatbuffers::String> target_component_id) {
    fbb_.AddOffset(Connection::VT_TARGET_COMPONENT_ID, target_component_id);
  }
  void add_target_io_id(::flatbuffers::Offset<::flatbuffers::String> target_io_id) {
    fbb_.AddOffset(Connection::VT_TARGET_IO_ID, target_io_id);
  }
  explicit ConnectionBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Connection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Connection>(end);
    fbb_.Required(o, Connection::VT_ID);
    fbb_.Required(o, Connection::VT_SOURCE_COMPONENT_ID);
    fbb_.Required(o, Connection::VT_SOURCE_IO_ID);
    fbb_.Required(o, Connection::VT_TARGET_COMPONENT_ID);
    fbb_.Required(o, Connection::VT_TARGET_IO_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<Connection> CreateConnection(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    plant_composer::fbs::ConnectionType type = plant_composer::fbs::ConnectionType_Port,
    ::flatbuffers::Offset<::flatbuffers::String> source_component_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> source_io_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> target_component_id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> target_io_id = 0) {
  ConnectionBuilder builder_(_fbb);
  builder_.add_target_io_id(target_io_id);
  builder_.add_target_component_id(target_component_id);
  builder_.add_source_io_id(source_io_id);
  builder_.add_source_component_id(source_component_id);
  builder_.add_id(id);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Connection> CreateConnectionDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    plant_composer::fbs::ConnectionType type = plant_composer::fbs::ConnectionType_Port,
    const char *source_component_id = nullptr,
    const char *source_io_id = nullptr,
    const char *target_component_id = nullptr,
    const char *target_io_id = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto source_component_id__ = source_component_id ? _fbb.CreateString(source_component_id) : 0;
  auto source_io_id__ = source_io_id ? _fbb.CreateString(source_io_id) : 0;
  auto target_component_id__ = target_component_id ? _fbb.CreateString(target_component_id) : 0;
  auto target_io_id__ = target_io_id ? _fbb.CreateString(target_io_id) : 0;
  return plant_composer::fbs::CreateConnection(
      _fbb,
      id__,
      type,
      source_component_id__,
      source_io_id__,
      target_component_id__,
      target_io_id__);
}

struct DiagramTable FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DiagramTableBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_NAME = 6,
    VT_WIDTH = 8,
    VT_HEIGHT = 10,
    VT_COMPONENTS = 12,
    VT_CONNECTIONS = 14
  };
  const ::flatbuffers::String *id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ID);
  }
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  int32_t width() const {
    return GetField<int32_t>(VT_WIDTH, 0);
  }
  int32_t height() const {
    return GetField<int32_t>(VT_HEIGHT, 0);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::ComponentInstance>> *components() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::ComponentInstance>> *>(VT_COMPONENTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::Connection>> *connections() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::Connection>> *>(VT_CONNECTIONS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyOffset(verifier, VT_COMPONENTS) &&
           verifier.VerifyVector(components()) &&
           verifier.VerifyVectorOfTables(components()) &&
           VerifyOffset(verifier, VT_CONNECTIONS) &&
           verifier.VerifyVector(connections()) &&
           verifier.VerifyVectorOfTables(connections()) &&
           verifier.EndTable();
  }
};

struct DiagramTableBuilder {
  typedef DiagramTable Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_id(::flatbuffers::Offset<::flatbuffers::String> id) {
    fbb_.AddOffset(DiagramTable::VT_ID, id);
  }
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DiagramTable::VT_NAME, name);
  }
  void add_width(int32_t width) {
    fbb_.AddElement<int32_t>(DiagramTable::VT_WIDTH, width, 0);
  }
  void add_height(int32_t height) {
    fbb_.AddElement<int32_t>(DiagramTable::VT_HEIGHT, height, 0);
  }
  void add_components(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::ComponentInstance>>> components) {
    fbb_.AddOffset(DiagramTable::VT_COMPONENTS, components);
  }
  void add_connections(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::Connection>>> connections) {
    fbb_.AddOffset(DiagramTable::VT_CONNECTIONS, connections);
  }
  explicit DiagramTableBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DiagramTable> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DiagramTable>(end);
    fbb_.Required(o, DiagramTable::VT_ID);
    return o;
  }
};

inline ::flatbuffers::Offset<DiagramTable> CreateDiagramTable(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> id = 0,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    int32_t width = 0,
    int32_t height = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::ComponentInstance>>> components = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<plant_composer::fbs::Connection>>> connections = 0) {
  DiagramTableBuilder builder_(_fbb);
  builder_.add_connections(connections);
  builder_.add_components(components);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_name(name);
  builder_.add_id(id);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DiagramTable> CreateDiagramTableDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *name = nullptr,
    int32_t width = 0,
    int32_t height = 0,
    const std::vector<::flatbuffers::Offset<plant_composer::fbs::ComponentInstance>> *components = nullptr,
    const std::vector<::flatbuffers::Offset<plant_composer::fbs::Connection>> *connections = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto components__ = components ? _fbb.CreateVector<::flatbuffers::Offset<plant_composer::fbs::ComponentInstance>>(*components) : 0;
  auto connections__ = connections ? _fbb.CreateVector<::flatbuffers::Offset<plant_composer::fbs::Connection>>(*connections) : 0;
  return plant_composer::fbs::CreateDiagramTable(
      _fbb,
      id__,
      name__,
      width,
      height,
      components__,
      connections__);
}

inline const plant_composer::fbs::DiagramTable *GetDiagramTable(const void *buf) {
  return ::flatbuffers::GetRoot<plant_composer::fbs::DiagramTable>(buf);
}

inline const plant_composer::fbs::DiagramTable *GetSizePrefixedDiagramTable(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<plant_composer::fbs::DiagramTable>(buf);
}

inline bool VerifyDiagramTableBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<plant_composer::fbs::DiagramTable>(nullptr);
}

inline bool VerifySizePrefixedDiagramTableBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<plant_composer::fbs::DiagramTable>(nullptr);
}

inline void FinishDiagramTableBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<plant_composer::fbs::DiagramTable> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDiagramTableBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<plant_composer::fbs::DiagramTable> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace fbs
}  // namespace plant_composer

#endif  // FLATBUFFERS_GENERATED_DIAGRAM_PLANT_COMPOSER_FBS_H_
